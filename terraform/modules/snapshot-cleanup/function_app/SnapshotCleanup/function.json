import logging
import os
import datetime
import json
import azure.functions as func
from azure.identity import ManagedIdentityCredential
from azure.storage.blob import BlobServiceClient

# Import AzureSnapshotManager class from script
import sys
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from SnapshotCleanup import AzureSnapshotManager

def main(mytimer: func.TimerRequest, req: func.HttpRequest = None) -> func.HttpResponse:
    """
    Azure Function entry point - can be triggered by timer or HTTP request
    
    Args:
        mytimer: Timer trigger
        req: HTTP request (optional)
        
    Returns:
        HTTP response (if triggered via HTTP)
    """
    # Initialize logging
    log_level = os.environ.get("LOG_LEVEL", "INFO")
    logging.getLogger().setLevel(getattr(logging, log_level))
    logging.info("Azure Snapshot Cleanup Function started")
    
    # Get configuration from environment variables
    subscription_id = os.environ.get("SUBSCRIPTION_ID", None)
    enable_deletion = os.environ.get("ENABLE_DELETION", "false").lower() == "true"
    dry_run = os.environ.get("DRY_RUN", "true").lower() == "true"
    managed_identity_client_id = os.environ.get("MANAGED_IDENTITY_CLIENT_ID")
    storage_connection_string = os.environ.get("STORAGE_CONNECTION_STRING")
    storage_container_name = os.environ.get("STORAGE_CONTAINER_NAME", "reports")
    
    # Check if this is an HTTP request
    is_http_request = req is not None
    
    # If HTTP request, get parameters from query string
    if is_http_request:
        subscription_id = req.params.get("subscriptionId") or subscription_id
        enable_deletion = req.params.get("enableDeletion", "").lower() == "true" or enable_deletion
        dry_run = req.params.get("dryRun", "").lower() != "false" and dry_run
    
    try:
        # Get managed identity credential
        credential = ManagedIdentityCredential(client_id=managed_identity_client_id)
        
        # Initialize the snapshot manager
        snapshot_manager = AzureSnapshotManager(
            credential=credential,
            subscription_id=subscription_id,
            log_level=log_level
        )
        
        # Find orphaned snapshots
        orphaned_snapshots = snapshot_manager.find_orphaned_snapshots()
        
        # Generate the report data
        report_data = {
            "timestamp": datetime.datetime.utcnow().isoformat(),
            "subscription_id": subscription_id or "all_subscriptions",
            "orphaned_snapshots": orphaned_snapshots,
            "total_count": len(orphaned_snapshots),
            "total_size_gb": sum(s.get('size_gb', 0) for s in orphaned_snapshots),
            "enable_deletion": enable_deletion,
            "dry_run": dry_run
        }
        
        # Create summary text
        summary = []
        summary.append(f"Found {len(orphaned_snapshots)} orphaned snapshots")
        
        if not orphaned_snapshots:
            logging.info("No orphaned snapshots found")
        else:
            # Group by subscription
            by_sub = {}
            for snapshot in orphaned_snapshots:
                sub_name = snapshot.get('subscription_name', 'Unknown')
                if sub_name not in by_sub:
                    by_sub[sub_name] = []
                by_sub[sub_name].append(snapshot)
            
            # Add subscription breakdown to summary
            summary.append("\nBreakdown by subscription:")
            for sub_name, snapshots in by_sub.items():
                sub_size = sum(s.get('size_gb', 0) for s in snapshots)
                summary.append(f"  - {sub_name}: {len(snapshots)} snapshots, {sub_size} GB")
        
        # Delete orphaned snapshots if requested
        if orphaned_snapshots and enable_deletion:
            successful, failed = snapshot_manager.delete_orphaned_snapshots(dry_run=dry_run)
            
            # Add deletion results to report and summary
            report_data["deletion_results"] = {
                "successful": successful,
                "failed": failed,
                "dry_run": dry_run
            }
            
            summary.append(f"\nDeletion summary (dry run: {dry_run}):")
            summary.append(f"  - Successful: {successful}")
            summary.append(f"  - Failed: {failed}")
        
        # Save report to blob storage if configured
        if storage_connection_string and storage_container_name:
            try:
                blob_service_client = BlobServiceClient.from_connection_string(storage_connection_string)
                container_client = blob_service_client.get_container_client(storage_container_name)
                
                # Create blob name with timestamp
                timestamp = datetime.datetime.utcnow().strftime("%Y%m%d_%H%M%S")
                blob_name = f"snapshot_report_{timestamp}.json"
                
                # Upload report as JSON
                blob_client = container_client.get_blob_client(blob_name)
                blob_client.upload_blob(json.dumps(report_data, indent=2), overwrite=True)
                
                logging.info(f"Report saved to blob storage: {blob_name}")
                
                # Add storage info to report data
                report_data["report_blob_name"] = blob_name
                report_data["report_container_name"] = storage_container_name
                
            except Exception as e:
                logging.error(f"Error saving report to blob storage: {str(e)}")
        
        # Return HTTP response if this is an HTTP request
        if is_http_request:
            return func.HttpResponse(
                body=json.dumps(report_data, indent=2),
                mimetype="application/json",
                status_code=200
            )
            
        return None
        
    except Exception as e:
        error_message = f"Error in Azure Snapshot Cleanup Function: {str(e)}"
        logging.error(error_message)
        
        if is_http_request:
            return func.HttpResponse(
                body=json.dumps({"error": error_message}),
                mimetype="application/json",
                status_code=500
            )
            
        return None
